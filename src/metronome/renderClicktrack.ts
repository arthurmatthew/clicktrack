import { Clicktrack } from '../models/Clicktrack';
import { Metronome } from '../models/Metronome';
import { Repeat } from '../models/Repeat';
import { Transition } from '../models/Transition';
import { getEffectiveBpm } from '../utils/getEffectiveBpm';
import { playClick } from './playClick';

// generated by claude

interface RenderOptions {
  sampleRate?: number;
  addSilenceAtEnd?: number;
}

export const renderClicktrackToAudio = async (
  clicktrack: Clicktrack,
  options: RenderOptions = {},
): Promise<Blob> => {
  const { sampleRate = 44100, addSilenceAtEnd = 1 } = options;

  const totalDuration = calculateTotalDuration(clicktrack);
  const durationWithBuffer = totalDuration + addSilenceAtEnd;

  const offlineCtx = new OfflineAudioContext(
    1, // mono
    durationWithBuffer * sampleRate,
    sampleRate,
  );

  scheduleAllClicks(offlineCtx, clicktrack);
  const renderedBuffer = await offlineCtx.startRendering();
  const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);

  return wavBlob;
};

const calculateTotalDuration = (clicktrack: Clicktrack): number => {
  let totalDuration = 0;
  let sectionIndex = 0;
  let repeatsTaken = new Map<string, number>();
  const sections = clicktrack.data.sections;

  while (sectionIndex < sections.length) {
    const section = sections[sectionIndex];

    if (section instanceof Repeat) {
      const taken = repeatsTaken.get(section.id) || 0;

      if (section.infinite) {
        // For infinite repeats just do one cycle for rendering
        break;
      }

      if (taken < section.times) {
        // Jump back to start and increment counter
        repeatsTaken.set(section.id, taken + 1);

        // Reset all repeats before this one
        const sectionsBeforeThisRepeat = sections.slice(0, sectionIndex);
        sectionsBeforeThisRepeat.forEach((s) => {
          if (s instanceof Repeat) {
            repeatsTaken.set(s.id, 0);
          }
        });

        sectionIndex = 0; // Jump back to start
      } else {
        sectionIndex++;
      }
    } else if (section instanceof Metronome || section instanceof Transition) {
      const bpm =
        section instanceof Metronome
          ? section.bpm
          : section.fromMetronome?.bpm || 120;
      const timeSignature = section.timeSignature || [4, 4];
      const beatsPerBar = timeSignature[0] / (timeSignature[1] / 4);
      const secondsPerBeat = 60.0 / bpm;
      const barDuration = beatsPerBar * secondsPerBeat;

      totalDuration += section.lengthInBars * barDuration;
      sectionIndex++;
    } else {
      sectionIndex++;
    }
  }

  return totalDuration;
};

const scheduleAllClicks = (
  offlineCtx: OfflineAudioContext,
  clicktrack: Clicktrack,
) => {
  let currentTime = 0;
  let current16thBeat = 0;
  let totalBarsPlayed = 0;
  let totalSectionsPlayed = 0;
  let repeatsTaken = new Map<string, number>();

  const getCurrentSection = () => {
    const sections = clicktrack.data.sections;
    const current = sections[totalSectionsPlayed];
    const previous = sections[totalSectionsPlayed - 1];
    const lastMetronome = sections.findLast(
      (section) => section instanceof Metronome,
    ) as Metronome | undefined;

    return current || (previous instanceof Repeat ? lastMetronome : previous);
  };

  const handleRepeat = (section: Repeat, index: number): boolean => {
    if (!repeatsTaken.has(section.id)) {
      repeatsTaken.set(section.id, 0);
    }

    const taken = repeatsTaken.get(section.id)!;

    if (section.infinite) {
      // For rendering, just do one cycle
      totalSectionsPlayed = sections.length;
      return true;
    }

    if (taken === section.times) {
      totalSectionsPlayed = index + 1;
      return true;
    }

    totalSectionsPlayed = 0;
    const sectionsBeforeThisRepeat = clicktrack.data.sections.slice(0, index);
    sectionsBeforeThisRepeat.forEach((s) => {
      if (s instanceof Repeat) {
        repeatsTaken.set(s.id, 0);
      }
    });

    repeatsTaken.set(section.id, taken + 1);
    return true;
  };

  const sections = clicktrack.data.sections;

  while (totalSectionsPlayed < sections.length) {
    const section = getCurrentSection();

    if (!section) break;

    if (section instanceof Repeat) {
      handleRepeat(section, totalSectionsPlayed);
      continue;
    }

    if (!(section instanceof Metronome || section instanceof Transition)) {
      totalSectionsPlayed++;
      continue;
    }

    const timeSignature = section.timeSignature || [4, 4];
    const quarterNotesPerBar = timeSignature[0] / (timeSignature[1] / 4);
    const sixteenthNotesPerBar = quarterNotesPerBar * 4;

    let bpm: number;
    if (section instanceof Metronome) {
      bpm = section.bpm;
    } else {
      bpm = getEffectiveBpm(
        section.fromMetronome!.bpm,
        section.toMetronome!.bpm,
        section.lengthInBars,
        timeSignature,
        section.curveType,
        totalBarsPlayed,
        current16thBeat,
      );
    }

    const secondsPerBeat = 60.0 / bpm;
    const secondsPer16thNote = 0.25 * secondsPerBeat;

    // Schedule click for current beat
    if (section instanceof Transition) {
      if (section.accentMap && section.fromMetronome && section.toMetronome) {
        const accent = section.accentMap[current16thBeat] ?? 0;
        if (accent > 0) {
          playClick(
            offlineCtx,
            clicktrack,
            current16thBeat,
            accent,
            new Metronome({ ...section, bpm }),
            currentTime,
            () => {},
          );
        }
      }
    } else {
      const accent = section.accentMap[current16thBeat] ?? 0;
      if (accent > 0) {
        playClick(
          offlineCtx,
          clicktrack,
          current16thBeat,
          accent,
          section,
          currentTime,
          () => {},
        );
      }
    }

    // Advance
    currentTime += secondsPer16thNote;
    current16thBeat++;

    if (current16thBeat >= sixteenthNotesPerBar) {
      current16thBeat = 0;
      totalBarsPlayed++;
    }

    if (totalBarsPlayed >= section.lengthInBars) {
      totalBarsPlayed = 0;
      totalSectionsPlayed++;
    }
  }
};

const bufferToWave = (abuffer: AudioBuffer, len: number): Blob => {
  const numOfChan = abuffer.numberOfChannels;
  const length = len * numOfChan * 2 + 44;
  const buffer = new ArrayBuffer(length);
  const view = new DataView(buffer);
  const channels: Float32Array[] = [];
  let offset = 0;
  let pos = 0;

  // Write WAVE header
  setUint32(0x46464952); // "RIFF"
  setUint32(length - 8); // file length - 8
  setUint32(0x45564157); // "WAVE"

  setUint32(0x20746d66); // "fmt " chunk
  setUint32(16); // length = 16
  setUint16(1); // PCM (uncompressed)
  setUint16(numOfChan);
  setUint32(abuffer.sampleRate);
  setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
  setUint16(numOfChan * 2); // block-align
  setUint16(16); // 16-bit (hardcoded in this demo)

  setUint32(0x61746164); // "data" - chunk
  setUint32(length - pos - 4); // chunk length

  // Write interleaved data
  for (let i = 0; i < abuffer.numberOfChannels; i++) {
    channels.push(abuffer.getChannelData(i));
  }

  while (pos < length) {
    for (let i = 0; i < numOfChan; i++) {
      const channelData = channels[i]?.[offset] ?? 0;
      let sample = Math.max(-1, Math.min(1, channelData));
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7fff;
      view.setInt16(pos, sample, true);
      pos += 2;
    }
    offset++;
  }

  return new Blob([buffer], { type: 'audio/wav' });

  function setUint16(data: number) {
    view.setUint16(pos, data, true);
    pos += 2;
  }

  function setUint32(data: number) {
    view.setUint32(pos, data, true);
    pos += 4;
  }
};

export const downloadClicktrack = async (
  clicktrack: Clicktrack,
  filename: string = 'clicktrack.wav',
) => {
  const audioBlob = await renderClicktrackToAudio(clicktrack);
  const url = URL.createObjectURL(audioBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
};
